{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Vellox","text":"<p>Vellox is an adapter for running ASGI applications in GCP Cloud Functions.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Event handlers for GCP Cloud Functions.</p> </li> <li> <p>Compatibility with ASGI application frameworks, such as Starlette, FastAPI, Quart and Django.</p> </li> <li> <p>Support for binary media types and payload compression in API Gateway using GZip or Brotli.</p> </li> <li> <p>Startup and shutdown lifespan events.</p> </li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Python 3.8+</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install vellox\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>from vellox import Vellox\n\nasync def app(scope, receive, send):\n    await send(\n        {\n            \"type\": \"http.response.start\",\n            \"status\": 200,\n            \"headers\": [[b\"content-type\", b\"text/plain; charset=utf-8\"]],\n        }\n    )\n    await send({\"type\": \"http.response.body\", \"body\": b\"Hello, world!\"})\n\n\nvellox = Vellox(app=app, lifespan=\"off\")\n\ndef handler(request):\n    return vellox(request)\n</code></pre> <p>Or using a framework:</p> <pre><code>from fastapi import FastAPI\nfrom vellox import Vellox\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: str = None):\n    return {\"item_id\": item_id, \"q\": q}\n\nvellox = Vellox(app=app, lifespan=\"off\")\n\ndef handler(request):\n    return vellox(request)\n</code></pre>"},{"location":"adapter/","title":"Adapter","text":"<p>The heart of Vellex is the adapter class. It is a configurable wrapper that allows any ASGI application (or framework) to run in GCP Cloud Functions deployment. The adapter accepts a number of keyword arguments to configure settings related to HTTP responses, ASGI lifespan, and Base path configuration.</p> <pre><code>handler = Vellox(\n    app,\n    lifespan=\"auto\",\n    base_path=\"/\",\n    custom_handlers=None,\n    text_mime_types=None,\n    exclude_headers=None\n)\n</code></pre> <p>All arguments are optional.</p>"},{"location":"adapter/#configuring-an-adapter-instance","title":"Configuring an adapter instance","text":"class <code>vellox.adapter.Vellox</code>(app, lifespan='auto', base_path='/', custom_handlers=None, text_mime_types=None, exclude_headers=None)"},{"location":"adapter/#creating-an-cloud-functions-handler","title":"Creating an Cloud Functions handler","text":"<p>The adapter can be used to wrap any application without referencing the underlying methods. It defines a <code>__call__</code> method that allows the class instance to be used as an Cloud Functions handler function.</p> <pre><code>from fastapi import FastAPI\nfrom vellox import Vellox\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: str = None):\n    return {\"item_id\": item_id, \"q\": q}\n\nvellox = Vellox(app=app, lifespan=\"off\")\n\ndef handler(request):\n    return vellox(request)\n</code></pre> <p>However, this is just one convention, you may also intercept events and construct the adapter instance separately. This may be useful if you need to implement custom event handling. The <code>handler</code> in the example above could be replaced with a function.</p> <pre><code>def handler(request : flask.Request):\n    if request.method not in [\"GET\", \"POST\"]:\n        # Do something or return, etc.\n        return\n\n    asgi_handler = Vellox(app)\n    response = vellox(request) # Call the instance with the event arguments\n\n    return response\n</code></pre>"},{"location":"adapter/#retrieving-the-aws-event-and-context","title":"Retrieving the AWS event and context","text":"<p>The GCP Cloud Functions handler <code>request</code> arguments are made available to an ASGI application in the ASGI connection scope.</p> <pre><code>scope['flask.request']\n</code></pre> <p>For example, if you're using FastAPI it can be retrieved from the <code>scope</code> attribute of the request object.</p> <pre><code>from fastapi import FastAPI\nfrom vellox import Vellox\nfrom starlette.requests import Request\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef hello(request: Request):\n    return {\"aws_event\": request.scope['flask.request']}\n\nvellox = Vellox(app=app)\n\ndef handler(request):\n    return vellox(request)\n</code></pre>"},{"location":"asgi-frameworks/","title":"Frameworks","text":"<p>Vellox is intended to provide support to any ASGI (Asynchronous Server Gateway Interface) application or framework. The \"turtles all the way down\" principle of ASGI allows for a great deal of interoperability across many different implementations, so the adapter should \"just work\"* for any ASGI application or framework.</p> <p>* if it doesn't, then please open an issue. :)</p>"},{"location":"asgi-frameworks/#background","title":"Background","text":"<p>We can think about the ASGI framework support without referencing an existing implementation. There are no framework-specific rules or dependencies in the adapter class, and all applications will be treated the same.</p> <p>Let's invent an API for a non-existent microframework to demonstrate things further. This could represent any ASGI framework application:</p> <pre><code>import vellox.adapter\nimport framework\nfrom vellox import Vellox\n\napp = framework.applications.Application()\n\n\n@app.route(\"/\")\ndef endpoint(request: framework.requests.Request) -&gt; dict:\n    return {\"hi\": \"there\"}\n\n\nvellox = Vellox(app)\n\ndef handler(request):\n    return vellox(request)\n</code></pre> <p>None of the framework details are important here. The routing decorator, request parameter, and return value of the endpoint method could be anything. The <code>app</code> instance will be a valid <code>app</code> parameter for Vellox so long as the framework exposes an ASGI-compatible interface:</p> <pre><code>class Application(Protocol):\n    async def __call__(self, scope: Scope, receive: ASGIReceive, send: ASGISend) -&gt; None:\n        ...\n</code></pre>"},{"location":"asgi-frameworks/#limitations","title":"Limitations","text":"<p>An application or framework may implement behaviour that is incompatible with the limitations of GCP Cloud Functions, and there may be additional configuration required depending on a particular deployment circumstance. In some cases it is possible to work around these limitations, but these kinds of limitations should generally be dealt with outside of Vellox itself.</p>"},{"location":"asgi-frameworks/#frameworks_1","title":"Frameworks","text":"<p>The examples on this page attempt to demonstrate a basic implementation of a particular framework (usually from official documentation) to highlight the interaction with Vellox. Specific deployment tooling, infrastructure, external dependencies, etc. are not taken into account.</p>"},{"location":"asgi-frameworks/#starlette","title":"Starlette","text":"<p>Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services.</p> <p>Vellox uses it as a toolkit in tests. It is developed by Encode, a wonderful community and collection of projects that are forming the foundations of the Python async web ecosystem.</p> <p>Define an application:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\nfrom vellox import Vellox\n\n\nasync def homepage(request):\n    return JSONResponse({'hello': 'world'})\n\nroutes = [\n    Route(\"/\", endpoint=homepage)\n]\n\napp = Starlette(debug=True, routes=routes)\n</code></pre> <p>Then wrap it using Vellox:</p> <pre><code>vellox = Vellox(app)\n\ndef handler(request):\n    return vellox(request)\n</code></pre>"},{"location":"asgi-frameworks/#fastapi","title":"FastAPI","text":"<p>FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints.</p> <pre><code>from fastapi import FastAPI\nfrom vellox import Vellox\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: str = None):\n    return {\"item_id\": item_id, \"q\": q}\n\nvellox = Vellox(app)\n\ndef handler(request):\n    return vellox(request)\n</code></pre>"},{"location":"asgi-frameworks/#responder","title":"Responder","text":"<p>Responder is a familiar HTTP Service Framework for Python, powered by Starlette. The <code>static_dir</code> and <code>templates_dir</code> parameters must be set to none to disable Responder's automatic directory creation behaviour because GCP Cloud Functions is a read-only file system - see the limitations section for more details.</p> <pre><code>from vellox import Vellox\nimport responder\n\napp = responder.API(static_dir=None, templates_dir=None)\n\n\n@app.route(\"/{greeting}\")\nasync def greet_world(req, resp, *, greeting):\n    resp.text = f\"{greeting}, world!\"\n\n\nvellox = Vellox(app)\n\ndef handler(request):\n    return vellox(request)\n</code></pre> <p>The adapter usage for both FastAPI and Responder is the same as Starlette. However, this may be expected because they are built on Starlette - what about other frameworks?</p>"},{"location":"asgi-frameworks/#quart","title":"Quart","text":"<p>Quart is a Python ASGI web microframework. It is intended to provide the easiest way to use asyncio functionality in a web context, especially with existing Flask apps. This is possible as the Quart API is a superset of the Flask API.</p> <pre><code>from quart import Quart\nfrom vellox import Vellox\n\napp = Quart(__name__)\n\n\n@app.route(\"/hello\")\nasync def hello():\n    return \"hello world!\"\n\nvellox = Vellox(app)\n\ndef handler(request):\n    return vellox(request)\n</code></pre>"},{"location":"asgi-frameworks/#sanic","title":"Sanic","text":"<p>Sanic is a Python web server and web framework that's written to go fast. It allows the usage of the async/await syntax added in Python 3.5, which makes your code non-blocking and speedy.</p> <pre><code>from sanic import Sanic\nfrom sanic.response import json\nfrom vellox import Vellox\n\napp = Sanic()\n\n\n@app.route(\"/\")\nasync def test(request):\n    return json({\"hello\": \"world\"})\n\n\nvellox = Vellox(app)\n\ndef handler(request):\n    return vellox(request)\n</code></pre>"},{"location":"asgi-frameworks/#django","title":"Django","text":"<p>Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design.</p> <p>It started introducing ASGI support in version 3.0. Certain async capabilities are not yet implemented and planned for future releases, however it can still be used with Vellox and other ASGI applications at the outer application level.</p> <pre><code># asgi.py\nimport os\nfrom vellox import Vellox\nfrom django.core.asgi import get_asgi_application\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"app.settings\")\n\napplication = get_asgi_application()\n\nvellox = Vellox(app, lifespan=\"off\")\n\ndef handler(request):\n    return vellox(request)\n</code></pre> <p>This example looks a bit different than the others because it is based on Django's standard project configuration, but the ASGI behaviour is the same.</p>"},{"location":"asgi-frameworks/#channels","title":"Channels","text":"<p>Channels is a project that takes Django and extends its abilities beyond HTTP - to handle WebSockets, chat protocols, IoT protocols, and more. It is the original driving force behind the ASGI specification.</p> <p>It currently does not support ASGI version 3, but you can convert the application from ASGI version 2 using the <code>guarantee_single_callable</code> method provided in asgiref.</p> <pre><code># asgi.py\nimport os\nimport django\nfrom channels.routing import get_default_application\nfrom asgiref.compatibility import guarantee_single_callable\nfrom vellox import Vellox\n\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"project.settings\")\ndjango.setup()\napplication = get_default_application()\n\nwrapped_application = guarantee_single_callable(application)\n\nvellox = Vellox(wrapped_application, lifespan=\"off\")\n\ndef handler(request):\n    return vellox(request)\n</code></pre>"},{"location":"contributing/","title":"Contributing to Vellox","text":"<p>Hello. Contributions to this project are highly encouraged and appreciated. This document will outline some general guidelines for how to get started.</p>"},{"location":"contributing/#contents","title":"Contents","text":"<ul> <li>Creating a pull request<ul> <li>Setting up the repository</li> </ul> </li> <li>Using the issue tracker<ul> <li>Technical support</li> <li>Feature requests</li> </ul> </li> </ul>"},{"location":"contributing/#creating-a-pull-request","title":"Creating a pull request","text":"<p>Non-trivial changes, especially those that could impact existing behaviour, should have an associated issue created for discussion. An issue isn't strictly required for larger changes, but it can be helpful to discuss first.</p> <p>Minor changes generally should not require a new issue and can be explained in the pull request description.</p>"},{"location":"contributing/#setting-up-the-repository","title":"Setting up the repository","text":"<p>To create a pull request, you must first fork the repository in GitHub, then clone the fork locally.</p> <pre><code>git clone git@github.com:&lt;YOUR-USERNAME&gt;/vellox.git\n</code></pre> <p>Then add the upstream remote to keep the forked repo in sync with the original.</p> <pre><code>cd vellox\ngit remote add upstream git://github.com/junah201/vellox.git\ngit fetch upstream\n</code></pre> <p>Then to keep in sync with changes in the primary repository, you pull the upstream changes into your local fork.</p> <pre><code>git pull upstream main\n</code></pre>"},{"location":"contributing/#using-the-issue-tracker","title":"Using the issue tracker","text":"<p>The issue tracker can be used for different types of discussion, but it is mainly intended for items that are relevant to this project specifically.</p> <p>Here are a few things you might consider before opening a new issue:</p> <ul> <li> <p>Is this covered in the documentation?</p> </li> <li> <p>Is there already a related issue in the tracker?</p> </li> <li> <p>Is this a problem related to Vellox itself or a third-party dependency?</p> </li> </ul> <p>It may still be perfectly valid to open an issue if one or more of these is true, but thinking about these questions might help reveal an existing answer sooner.</p>"},{"location":"contributing/#technical-support","title":"Technical support","text":"<p>You may run into problems running Vellox that are related to a deployment tool (e.g. Serverless Framework), an ASGI framework (e.g. FastAPI), or some other external dependency. It is okay to use the tracker to resolve these kinds of issues, but keep in mind that this project does not guaruntee support for all the features of any specific ASGI framework or external tool.</p> <p>Note: These issues will typlically be closed, but it is fine to continue discussion on a closed issue. These issues will be re-opened only if a problem is discovered in Vellox itself.</p>"},{"location":"contributing/#feature-requests","title":"Feature requests","text":"<p>This project is intended to be small and focused on providing an adapter class for ASGI applications deployed in GCP Cloud Functions. Feature requests related to this use-case will generally be considered, but larger features that increase the overall scope of Vellox are less likely to be included.</p> <p>If you have a large feature request, please make an issue with sufficient detail and it can be discussed. Some feature requests may end up being rejected initially and re-considered later.</p>"},{"location":"contributing/#thank-you","title":"Thank you","text":"<p>:)</p>"},{"location":"external-links/","title":"External Links","text":"<p>External links related to using Vellox.</p> <p>If you're interested in contributing to this page, please open an issue</p>"},{"location":"http/","title":"HTTP","text":""},{"location":"http/#configuring-binary-responses","title":"Configuring binary responses","text":"<p>Binary responses are determined using the <code>Content-Type</code> and <code>Content-Encoding</code> headers from the event request and a list of text MIME types.</p>"},{"location":"http/#compression","title":"Compression","text":"<p>If the <code>Content-Encoding</code> header is set to <code>gzip</code> or <code>br</code>, then a binary response will be returned regardless of MIME type.</p>"},{"location":"http/#state-machine","title":"State machine","text":"<p>The <code>HTTPCycle</code> is used by the adapter to communicate message events between the application and GCP. It is a state machine that handles the entire ASGI request and response cycle.</p>"},{"location":"http/#httpcycle","title":"HTTPCycle","text":"class <code>vellox.protocols.http.HTTPCycle</code>(scope, body) async <code>run</code>(self, app) async <code>receive</code>(self) async <code>send</code>(self, message)"},{"location":"http/#httpcyclestate","title":"HTTPCycleState","text":"class <code>vellox.protocols.http.HTTPCycleState</code>(value, names=None, *, module=None, qualname=None, type=None, start=1) <p>The state of the ASGI <code>http</code> connection. * REQUEST - Initial state. The ASGI application instance will be run with the connection scope containing the <code>http</code> type. * RESPONSE - The <code>http.response.start</code> event has been sent by the application. The next expected message is the <code>http.response.body</code> event, containing the body content. An application may pass the <code>more_body</code> argument to send content in chunks, however content will always be returned in a single response, never streamed. * COMPLETE - The body content from the ASGI application has been completely read. A disconnect event will be sent to the application, and the response will be returned.</p>"},{"location":"lifespan/","title":"Lifespan","text":"<p>Vellox supports the ASGI Lifespan protocol. This allows applications to define lifespan startup and shutdown event handlers.</p> <pre><code>from vellox import Vellox\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    pass\n\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    pass\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\nvellox = Vellox(app, lifespan=\"auto\")\n\ndef handler(request):\n    return vellox(request)\n</code></pre>"},{"location":"lifespan/#configuring-lifespan-events","title":"Configuring Lifespan events","text":"<p>Lifespan support is automatically determined unless explicitly turned on or off. A string value option is used to configure lifespan support, the choices are <code>auto</code>, <code>on</code>, and <code>off</code>.</p>"},{"location":"lifespan/#options","title":"Options","text":"<ul> <li> <p>auto</p> <p>Application support for lifespan is inferred using the state transitions. Any error that occurs during startup will be logged and the ASGI application cycle will continue unless a <code>lifespan.startup.failed</code> event is sent.</p> </li> <li> <p>on</p> <p>Application support for lifespan is explicit. Any error that occurs during startup will be raised and a 500 response will be returned.</p> </li> <li> <p>off</p> <p>Application support for lifespan is ignored. The application will not enter the lifespan cycle context.</p> </li> </ul> <p>Defaults to <code>auto</code>.</p>"},{"location":"lifespan/#state-machine","title":"State machine","text":"<p>The <code>LifespanCycle</code> is a state machine that handles ASGI <code>lifespan</code> events intended to run before and after HTTP requests are handled.</p>"},{"location":"lifespan/#lifespancycle","title":"LifespanCycle","text":"class <code>vellox.protocols.lifespan.LifespanCycle</code>(app, lifespan) <p>Manages the application cycle for an ASGI <code>lifespan</code> connection.</p> <ul> <li>app - An asynchronous callable that conforms to version 3.0 of the ASGI specification. This will usually be an ASGI framework application instance.</li> <li>lifespan - A string to configure lifespan support. Choices are <code>auto</code>, <code>on</code>, and <code>off</code>. Default is <code>auto</code>.</li> <li>state - An enumerated <code>LifespanCycleState</code> type that indicates the state of the ASGI connection.</li> <li>exception - An exception raised while handling the ASGI event. This may or may not be raised depending on the state.</li> <li>app_queue - An asyncio queue (FIFO) containing messages to be received by the application.</li> <li>startup_event - An asyncio event object used to control the application startup flow.</li> <li>shutdown_event - An asyncio event object used to control the application shutdown flow.</li> </ul> async <code>run</code>(self) <p>Calls the application with the <code>lifespan</code> connection scope.</p> async <code>receive</code>(self) <p>Awaited by the application to receive ASGI <code>lifespan</code> events.</p> async <code>send</code>(self, message) <p>Awaited by the application to send ASGI <code>lifespan</code> events.</p> async <code>startup</code>(self) <p>Pushes the <code>lifespan</code> startup event to the queue and handles errors.</p> async <code>shutdown</code>(self) <p>Pushes the <code>lifespan</code> shutdown event to the queue and handles errors.</p>"},{"location":"lifespan/#context-manager","title":"Context manager","text":"<p>Unlike the <code>HTTPCycle</code> class, the <code>LifespanCycle</code> is also used as a context manager in the adapter class. If lifespan support is turned off, then the application never enters the lifespan cycle context.</p> <pre><code> with ExitStack() as stack:\n    # Ignore lifespan events entirely if the `lifespan` setting is `off`.\n    if self.lifespan in (\"auto\", \"on\"):\n        asgi_cycle: typing.ContextManager = LifespanCycle(\n            self.app, self.lifespan\n        )\n        stack.enter_context(asgi_cycle)\n</code></pre> <p>The magic methods <code>__enter__</code> and <code>__exit__</code> handle running the async tasks that perform startup and shutdown functions.</p> <pre><code>    def __enter__(self) -&gt; None:\n        \"\"\"\n        Runs the event loop for application startup.\n        \"\"\"\n        self.loop.create_task(self.run())\n        self.loop.run_until_complete(self.startup())\n\n    def __exit__(\n        self,\n        exc_type: typing.Optional[typing.Type[BaseException]],\n        exc_value: typing.Optional[BaseException],\n        traceback: typing.Optional[types.TracebackType],\n    ) -&gt; None:\n        \"\"\"\n        Runs the event loop for application shutdown.\n        \"\"\"\n        self.loop.run_until_complete(self.shutdown())\n</code></pre>"},{"location":"lifespan/#lifespancyclestate","title":"LifespanCycleState","text":"class <code>vellox.protocols.lifespan.LifespanCycleState</code>(value, names=None, *, module=None, qualname=None, type=None, start=1) <p>The state of the ASGI <code>lifespan</code> connection.</p> <ul> <li>CONNECTING - Initial state. The ASGI application instance will be run with the connection scope containing the <code>lifespan</code> type.</li> <li>STARTUP - The lifespan startup event has been pushed to the queue to be received by the application.</li> <li>SHUTDOWN - The lifespan shutdown event has been pushed to the queue to be received by the application.</li> <li>FAILED - A lifespan failure has been detected, and the connection will be closed with an error.</li> <li>UNSUPPORTED - An application attempted to send a message before receiving the lifepan startup event. If the lifespan argument is \"on\", then the connection will be closed with an error.</li> </ul>"}]}